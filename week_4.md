# 4주차

- 다음의 키워드에 대해 학습을 진행 (실습 포함)
- continuation, Dispatchers, async, launch, suspend, coroutineScope, coroutineContext, yield, runBlocking, withContext

<br>
<br>
<hr>
<br>
<br>


### suspend

- suspend 함수는 **일시 중지(suspension)**가 가능한 함수로, 이를 호출한 코루틴은 특정 지점에서 중단되고, 결과가 준비되면 다시 실행
- 비동기 작업을 처리할 수 있는 특수한 함수를 정의할 때 사용
- suspend 함수는 **일시 중지(suspension)**가 가능하며, 이를 통해 동기적인 코드처럼 보이지만 비동기적으로 실행되는 기능을 제공
- suspend 함수가 호출되면, 그 함수 내부에서 **일시 중지(suspension)**를 할 수 있는 시점에 코루틴이 중단
  - 그런 다음, 비동기 작업이 완료되면 코루틴이 다시 실행

**Reactor와의 가장 큰 차이점**

> 일반적인 비동기 방식에서는 Callback이나 Promise를 사용하지만, suspend 함수는 콜백 지옥을 피하고 동기적인 코드 스타일로 비동기 작업을 처리할 수 있습니다.


<br>
<br>
<hr>
<br>
<br>

### yield

> yield는 코루틴이 자발적으로 일시 중지할 수 있는 지점을 만드는 데 사용됩니다. 코루틴의 일시 중지 지점을 명시적으로 만들고, 다른 코루틴이 실행될 수 있도록 하여 스케줄링을 제공합니다.

**yield와 코루틴의 동작**

- yield는 코루틴을 일시 중지하고, 코루틴이 다시 실행되도록 요청하는 함수
- 주로 코루틴의 협력적 스케줄링을 제어하는 데 사용
- yield를 호출하면, 해당 코루틴은 일시 중지되고 다른 대기 중인 코루틴이 실행될 수 있게 함.
- 이 방식은 동시성을 관리하는 방법으로 사용되며, 주로 CPU 바운드 작업에서 실행을 "양보"할 때 유용

**yield() 내부 구현**

실제로 yield는 Kotlin 코루틴 라이브러리에서 어떻게 구현될까요? Kotlin의 코루틴은 협력적 스케줄링을 지원하는데, 이때 코루틴은 일시 중지 지점을 설정하고, 이를 관리하는 스케줄러가 존재합니다.

suspend 함수 내부에서 yield가 호출되면, 현재 실행 중인 코루틴은 중단되고, 다음 코루틴이 실행될 수 있게 스케줄링됩니다. 이때 중요한 것은 yield가 자발적으로 코루틴을 일시 중지하는 함수라는 점입니다.

**yield의 내부적인 흐름**

- yield()가 호출되면 현재 실행 중인 코루틴은 일시 중지되고, 해당 코루틴의 상태는 Continuation 객체에 저장
- 다른 대기 중인 코루틴이 재개되어 실행될 수 있음.
- 만약, 일시 중지된 코루틴이 다시 실행되면, Continuation을 통해 다시 실행
- 이 과정은 Kotlin 코루틴의 내부 스케줄러가 관리하고, 실제로는 코루틴의 상태 관리, 재개, 스케줄링 등을 담당

**yield의 성능 측면**

- yield는 협력적 스케줄링을 제공하므로, CPU 바운드 작업에서는 리소스를 효율적으로 분배
- 하지만, 과도하게 yield를 사용하는 것은 오히려 성능에 부담을 줄 수 있음.
- yield가 자주 호출되면, 그만큼 코루틴 간 전환 비용이 발생할 수 있기 때문

<br>
<br>
<hr>
<br>
<br>

### continuation

- 코루틴이 일시 중지된 지점과 상태를 추적하고, 해당 코루틴을 다시 실행할 수 있도록 관리하는 객체
- 코루틴이 일시 중지되는 시점에서 중단된 상태와 그 시점의 정보(상태, 인자, 로컬 변수 등)를 추적하고, 이후 다시 실행할 수 있게 관리하는 객체가 바로 Continuation

**주요 역할**

- 일시 중지된 상태 추적
  - 코루틴이 일시 중지되는 시점에서, 그 코루틴이 수행 중이던 작업에 대한 상태를 저장.
  - 이 상태 정보는 나중에 코루틴을 재개하는 데 필요.
- 코루틴 재개
  - 코루틴이 중단된 후, Continuation은 코루틴을 다시 실행(재개)할 수 있도록 관리이때, 일시 중지된 위치에서 작업이 재개되며, 코루틴이 다시 실행
- 결과 반환: Continuation은 코루틴이 실행을 마친 후 결과를 반환하는 책임 존재.
  - 코루틴의 종료 후, 해당 결과를 처리하는 데 사용

**continutation의 주요 속성**
- context
  - 코루틴의 실행 컨텍스트(디스패처, 직렬화 등) 정보를 담고 있는 CoroutineContext 객체
- resumeWith(result: Result<T>)
  - 코루틴을 재개하는 메서드
  - resumeWith는 코루틴을 재개할 때 사용되며, result에는 코루틴의 실행 결과
  - 성공적인 실행 결과는 Result.success(value)로 감싸지며, 예외가 발생하면 Result.failure(exception)으로 감쌈.

<br>
<br>
<hr>
<br>
<br>


### coroutineScope 

- coroutineScope는 코루틴 빌더의 일종으로, 새로운 **코루틴 범위(scope)**를 생성하고 그 범위 내에서 실행되는 모든 코루틴이 완료될 때까지 기다림.
- coroutineScope 내에서 예외가 발생하면, 예외가 상위 코루틴으로 전파되지 않도록 처리함.
- coroutineScope는 코루틴을 효율적으로 관리하고, 예외를 안전하게 처리하는 역할
- 새로운 코루틴 범위를 만들고, 해당 범위 내에서 실행되는 모든 코루틴이 완료될 때까지 기다리며, 예외가 발생해도 외부 코루틴으로 예외가 전파되지 않도록 안전하게 처리

<br>
<br>
<hr>
<br>
<br>

### coroutineContext

- 코루틴의 환경을 정의하고 관리하는 객체로, 코루틴의 디스패처(Dispatcher), Job, 예외 처리기, 제어 흐름 등을 설정하는 데 사용
- 코루틴의 실행 환경을 나타내며, 이를 통해 코루틴이 어떤 스레드에서 실행될지, 코루틴의 취소 및 예외 처리 방법을 지정

**개념 deep dive**

- coroutineContext는 코루틴의 실행 환경을 정의하는 Context 객체로, 여러 개의 **Element**가 결합된 집합체
- coroutineContext는 코루틴이 실행되는 동안 필요한 디스패처, Job, 예외 처리기 등을 제공하고, 코루틴이 시작될 때와 종료될 때, 그리고 중간에 상태가 변경될 때 이러한 요소들이 조합되어 실행
- coroutineContext는 코루틴의 실행 환경을 나타내는 속성으로, 코루틴이 실행되는 동안 사용할 수 있는 컨텍스트 요소들의 집합을 제공

**Job**

- Job은 코루틴의 상태와 관련된 정보를 담고 있는 객체
- Job은 코루틴이 시작되고, 완료되며, 취소될 수 있는지 여부를 추적
- Job을 통해 코루틴의 취소, 예외 처리와 같은 동작을 관리
  - Job을 사용하여 코루틴을 취소하거나, 다른 코루틴의 완료 여부를 기다릴 수 있음
  - Job은 코루틴의 계층 구조에서 부모-자식 관계를 관리

<br>
<br>
<hr>
<br>
<br>

### runBlocking



<br>
<br>
<hr>
<br>
<br>

### Dispatchers




### withContext



### async



### launch


