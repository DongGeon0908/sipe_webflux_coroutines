# 2주차

- 컨텍스트 스위치 비용 (하드웨어적으로) - 10분
- Atomic (CAS), Syncronized (lock), voilate, (FolkJoinPool, BlockingDeque, java.util.concurrent) - 10분
- Tomcat 네트워크 요청을 받아서, 스레드를 할당받고, 이게 스프링까지 넘어와서 어떤식으로 스레드가 처리되는지? - 10분

<br>
<hr>
<br>
<br>
<br>


# 컨텍스트 스위치 비용 (하드웨어적으로)

### 스레드와 프로세스에 대해...

- 자원 적인 측면
  - 프로세스간에는 자원을 모두 독립적으로 사용, 반면, 스레드의 경우에는 자원을 공유하여 사용
  - 프로세스간 작업 변경 진행시, 분리된 자원으로 스위칭 비용이 큼, 반면에 스레드의 스위칭은 동일 메모리이기 때문에 상대적으로 빠름

- 멀티 프로세스와 멀티스레딩 차이
  - 스레드의 경우, 동일 프로세스내에서 병렬 처리 진행
  - 프로세스의 경우, 다중 프로세스로 병렬 처리 진행

<br>
<hr>
<br>

### 병렬 처리와 동시성 처리의 차이

- 자원적인 측면
  - 병렬처리의 경우, core에 각각 스레드가 할당되어 작업을 처리하는 것을 의미
    - 스레드 n개를 병렬처리할려면, core도 n개가 있어야 한다.
  - 동시성 처리의 경우, core 1개에서 빠르게 스레드가 컨텍스트 스위칭 되면서 작업을 진행
    - ![image](https://github.com/user-attachments/assets/7e7e2086-b565-44e4-bc0e-0640dc4db033)

<br>
<hr>
<br>

### 병렬 프로세스에 대해 리소스 관점에서 고민해야할 부분은?

- CPU의 Core수에 따라 병렬처리가 가능한지 아닌지 알 수 있다.
  - core가 1개이면, 동시성 처리만 가능 

<br>
<hr>
<br>

### 컨텍스트 스위칭이란?

- 컨텍스트 스위칭은 CPU의 Core에 올라간 스레드가 짧은 주기를 가지고 계속 바뀌는 것을 의미
  - 빠르게 스레드를 스위칭하면서, 작업의 정보를 PCB 등에 기록
  - ![image](https://github.com/user-attachments/assets/2ba008c5-bccd-4024-8ef9-eccd3dfb450b)
  - 스레드가 스위칭되면서, 스레드별 고유한 메모리 영역인 stack 정보가 계속 바뀌게 된다.
  - ![image](https://github.com/user-attachments/assets/92b513f4-0ce3-4457-a348-c99727ae539c)

<br>
<hr>
<br>

### 컨텍스트 스위칭에 대해 우리가 고려해야 할 부분

- 과도한 컨텍스트 스위칭이 리소스에 어떤 문제를 야기할까?
  - 다수의 스레드가 특정 작업을 진행하는데 있어, 코어를 점유하지 못하고 계속 스위칭된다면, 전반적인 스레드 작업이 밀릴 수 있다.

<br>
<hr>
<br>

### 그외 컨텍스트 스위칭 비용 관련 내용

- 1. 스레드 및 프로세스 수 관리
  - 스레드 및 프로세스 수 제한: 많은 스레드나 프로세스가 실행되면 스케줄러는 빈번하게 작업을 교체해야 하므로 컨텍스트 스위칭 비용이 증가 -> 최소한의 스레드로 필요한 작업을 수행할 수 있도록 설계 필요.
  - 적절한 스레드 풀 크기 설정: 스레드 풀이 지나치게 크면 오버헤드가 증가하고, 너무 작으면 작업 지연이 생길 수 있음. -> CPU 코어 수와 애플리케이션의 부하를 고려하여 적절한 크기로 설정하는 것이 중요
- 2. CPU 캐시 효율성
  - 캐시 무효화 주의: 프로세스 또는 스레드를 전환할 때 CPU 캐시가 무효화되면 캐시 히트율이 떨어짐 -> 특히 데이터 처리가 많은 애플리케이션에서는 캐시 무효화가 성능에 큰 영향을 줄 수 있으므로, 같은 데이터에 반복적으로 접근하는 패턴을 만들거나 데이터 접근을 최적화하는 방식이 유리.
- 3. 동기화와 락(lock) 관리
  - 락 경합(lock contention) 최소화: 다중 스레드 환경에서는 공유 자원을 보호하기 위해 락이 필요할 수 있지만, 락이 많아지면 스레드 간 경합이 발생하고 컨텍스트 스위칭이 증가 -> 락이 필요한 부분을 최소화하고, 가능한 경우 락 프리(lock-free) 자료구조나 비동기적 방식을 고려
  - 락 범위 좁히기: 락이 걸린 영역(critical section)을 최대한 좁게 설정하면, 동기화 문제로 인한 불필요한 컨텍스트 스위칭을 줄일 수 있음.
- 4. I/O 작업 및 비동기 처리
  - 블로킹 I/O 회피: 네트워크나 파일 입출력과 같은 블로킹 I/O 작업은 스레드가 대기 상태에 들어가게 하므로, 그 사이에 다른 스레드로 전환되어 컨텍스트 스위칭이 발생합 -> 비동기 I/O 방식(예: Java NIO나 Spring WebFlux)을 사용하면 CPU가 대기 없이 다른 작업을 처리할 수 있어 오버헤드를 줄일 수 있음.
  - 적절한 비동기 API 사용: 비동기 API나 코루틴을 사용할 때에도 과도한 작업 분할이 이뤄지면 오히려 스레드 전환이 잦아질 수 있으므로, 적절히 조정된 비동기 작업을 유지하는 것이 중요.
- 5. 작업 단위 크기 조정
  - 작업 단위를 너무 작게 쪼개지 않기: 애플리케이션이 아주 작은 작업 단위로 쪼개져 있다면 스레드 교체가 빈번해지고, 컨텍스트 스위칭 오버헤드가 커질 수 있음. -> 가능하면 적절히 크고 연속적인 작업 단위를 유지하는 것이 좋음.
- 6. 스케줄링 정책 이해
  - 스케줄링 알고리즘 이해: Linux나 Windows와 같은 운영체제는 특정 스케줄링 알고리즘을 사용해 스레드를 관리. CPU 바운드와 I/O 바운드 작업이 혼합된 애플리케이션이라면, 스케줄링 알고리즘이 CPU 시간을 어떻게 분배하는지 알고 작업 특성에 맞게 튜닝하는 것이 좋음.
  - 우선순위 기반 스케줄링 주의: 우선순위 기반 스케줄링을 사용할 경우, 우선순위가 낮은 작업은 CPU 시간을 얻기 어려워질 수 있으며 오버헤드가 증가할 수 있음. 우선순위의 균형을 유지하고, 필요한 경우 우선순위 상속(priority inheritance) 같은 방식을 활용.
- 7. 가상 스레드와 같은 경량 스레드 사용 (Java)
  - 가상 스레드 활용: Java 19 이상에서 제공되는 가상 스레드는 컨텍스트 스위칭 비용을 줄일 수 있는 경량 스레드 모델. 가상 스레드는 OS 스레드가 아닌 JVM 레벨에서 관리되므로, 스레드가 많아도 상대적으로 적은 자원으로 관리할 수 있음.
  - 적합한 상황에서 가상 스레드 사용: CPU 바운드 작업이 아닌 I/O 바운드 작업에서 가상 스레드를 사용할 때 특히 효과적. 가상 스레드의 장점을 이해하고, 적절한 상황에서 사용해야 컨텍스트 스위칭 오버헤드를 줄이는 데 도움을 줌.
- 8. 시스템 모니터링 및 프로파일링
  - 프로파일링 툴 사용: VisualVM, JProfiler, perf 같은 프로파일링 툴을 사용하여 컨텍스트 스위칭이 많이 발생하는 구간을 모니터링하면, 성능 병목을 파악하고 이를 최적화 가능
  - 컨텍스트 스위칭 횟수 모니터링: 컨텍스트 스위칭이 많이 발생하는 경우, 운영체제의 모니터링 도구(예: Linux의 vmstat나 pidstat)를 통해 스레드 상태와 스위칭 횟수를 추적하면 성능 최적화의 방향을 잡는 데 도움을 줌



<br>
<hr>
<br>

### 그래서 멀티 스레드 프로그래밍에서 컨텍스트 스위칭 오버헤드를 어떻게 판단하는데?

- 병렬, 동시성 처리를 자주 하는 작업에 대하여, 꾸준하게 모니터링을 진행하고 -> 이를 통해 CPU Resource가 어떻게 할당되는지 확인
- 처리율, throughput 확인이 필요함..


<br>
<hr>
<br>

# Atomic (CAS), Syncronized (lock), voilate, (FolkJoinPool, BlockingDeque, java.util.concurrent) - 10분

<br>
<hr>
<br>
<br>
<br>
<br>
<br>
<br>

# Tomcat 네트워크 요청을 받아서, 스레드를 할당받고, 이게 스프링까지 넘어와서 어떤식으로 스레드가 처리되는지?


<br>
<hr>
<br>
